1首先把所有的基本类从核心类到驱动类全部写出，继承关系表达清楚
2然后把基本的成员，属性和方法全部列出
3然后处理关联属性-》但是这uml图感觉怪怪的，有些关联属性是单向的，我觉得应该是双向的.算了，
直接它写什么我实现什么吧
4开始对一遍函数名字，避免到时候使用junit测试的时候因为名字过不了   结果就是仍然有函数名字对应不上

5突然看到test里面好像有init函数，我都不知道在哪定义....好吧，原来是test文件里定义的
6可以在类内公用方法访问私有变量。因为私有变量是类级访问。//
7String内部的已经重写了字符串比较方法。尽管他们是不同对象，仍然会返回相等的值。就需要这个equals方法
8语法稍有不同，if后面的花括号必须在else头前才行//


9我也是服了，居然没写构造函数。。。
10构造函数还得跟着test里的构造写法来写，没让你传的参数就先别传参、、比如一些容器


11函数要不先跟随着test文件来写？因为这样才能知道逻辑，比如说什么时候初始化容器？容器什么时候用。
在哪里调用add函数这样的东西
12createTeam居然是个void类型的函数？那我create之后的实例化变量怎么传出去呢？

13主要关注程序的生命期
public class TeamManager {
    private Team team; // 实例变量，用于存储 Team 对象

    // 创建团队的方法
    public void createTeam() {
        team = new Team(); // 使用构造器创建 Team 对象并赋值给实例变量
        // 进行其他初始化操作
        team.initialize();
    }

    // 获取团队的方法
    public Team getTeam() {
        return team; // 返回创建的 Team 对象
    }
}
实例变量：在 TeamManager 类中，team 是一个实例变量。
通过将 Team 对象赋值给这个变量，你可以确保它在 TeamManager 实例的生命周期内存在。
实例变量：在 TeamManager 类中，team 是一个实例变量。通过将 Team 对象赋值给这个变量，
你可以确保它在 TeamManager 实例的生命周期内存在。
对象的生命周期：只要 TeamManager 实例存在，team 对象就会保持有效，直到 TeamManager 实例被垃圾回收。
但是问题在于，我的team不是，也不会是一个驱动类的容器内部的一个对象，所以我应该把这个create的team先放在这个学生的
容器里
这creator，这个Team里的对象居然是个Student对象。
它创建新的Team的时候，传入的creatorid，那我还得通过id来找到这个对象来进行构造team
内部复杂的关系，要记住，student才是维护那个teamlist的人（且只维护自己创造的teamlist）
也许就直接调用它内部的一个自己的构造器得了



思考一下问题。
如果是一个局部变量，在方法调用完之后会销毁
如果是一个类内部的实例变量or类变量，则不会。
但是问题是，现在这个Uss内部只需要维护一个userlist啊？
那也没关系，反正你可以把student这个类调出来，用它这个类创建的对象来维护对象所拥有的teamlist
这个问题稍有点复杂，我们先不去解决：：已经解决





13初始化Userlist并且实现一下add和remove
我们先尝试初始化Userlist。直接使用动态数组吧。ArrayList，它内部可以存各种对象，但是，
是不能直接存储基本数据类型的，只能存储它们的封装版本。这个也很好理解，毕竟是个指针数组，每一个元素的大小是固定的。
首先在无参的构造器里构造
可以在无参类型里的构造器里进行userlist的构造，然后直接把它当做arraylist构造
然后后面操作就利用arraylist来进行构造



迭代器的特性有点复杂，我写在我的迭代器文档里了，所以大部分时间我还是用for



getbydate这个有点令人头痛，因为对date一知半解，更是不知道比大小能否能使用
answer:它继承自comparable
如果调用的 Date 对象早于参数 Date 对象，则返回负整数。
如果调用的 Date 对象晚于参数 Date 对象，则返回正整数。
如果两个 Date 对象相等，则返回零。


退不出团队,这bug幽默完了


我真是服了。首先有个函数名字打错了
其次，我有个东西返回了普通list，但是它test里可不是普通list，是arraylist
无法解析的符号，junit。
https://www.cnblogs.com/wanglichaoya/p/10291445.html#:~:text=%E7%82%B9%E5%88%B0%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%BA%A2%E8%89%B2%E7%9A%84%E9%83%A8%E5%88%86%E6%98%BE%E7%A4%BA%EF%BC%9A%20Cannot%20resolve%20symbol%20%27junit%27%20%E8%A7%A3%E5%86%B3%EF%BC%9A%20File%20-%3E,-%3E%20%E6%89%BE%E5%88%B0%20IDEA%20%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84%E4%B8%8B%E7%9A%84%20Lib%20%E4%B8%AD%E7%9A%84junit-4.12%20-%3E%20%E7%A1%AE%E5%AE%9A%E5%AE%8C%E5%B0%B1%E8%A1%8C%E4%BA%86%EF%BC%8C%E7%82%B9%E5%87%BBOK%E5%B0%B1%E5%87%BA%E5%8E%BB%E4%BA%86
这个网址提供了解决方法。
但是framework也不行了？
okok,我这里搞好了。但是我还是找不到xml文件，也不知道自己的项目是什么
我估计我的文件是maven的。没问题，就是那个以你文件名开头的那个尾缀为xml的文件



真是服了，它自己说了要返回容器类，又没说用什么实现。你™自己写的List<Activity>
我统一建成List，然后实际上用array来实现，结果它还说我的返回值不对。。

只能在这里重新建立一下了。服了

我如果是这样声明的话 List<Activity> targetActivityList=new ArrayList<Activity>();//句子1
targetActivityList.add(targetactivity);调用的仍然是arraylist里的方法

在编译时的返回类型跟具体类型无关，比如说这个对象既是arraylist又是list类型，你甚至一开始是这样初始化的，
句子1，你返回仍然是父类

把人说晕了，我总结一下。
声明的时候，你写的是什么样的返回对象，那就一定是什么样的返回对象，编译的时候就会这么解释它


我想运行的时候只报了一个错误，那就是“java: 类 Test 是公共的, 应在名为 Test.java 的文件中声明”

13：04
初始化失败了，我真是服了，我得进行一次检查，然后再进行断点测试。
从核心类开始检查。
1Activity

草，核心类的Activity维护的居然是List，全给他改了去

activity 类全部检查完
team检查完了
user检查完了，我修改了一个user本身的方法，它本身是父类，居然去调用哪个Object的toString了


arraylist可能remove失败，因为空引用就无法进行删除，会返回false。。但这个到后面再解决吧。
而且本身arraylist本身要是空，你直接删除是会出问题的，这个应该也要try catch，



ok，发现是系统初始化没有做好，做好之后现在test6789出现问题
团队添加到某项活动中，某项活动中删除团队6
将教师添加到某项活动中、从某项活动中删除教师7
将主办方添加到某项活动中、从某项活动中删除主办方8
检查某个团队是否参加了多项活动10


我感觉还是初始化没做好，这test直接就用一个莫名其妙的活动，直接声明，然后add，根本就不打算初始化
可以，这初始化初始化明白了


jar文件是什么鬼啊？
类似于一个.zip
它用于将多个java类，资源文件，以及其他依赖文件打包在一起

然后把你要导入的，别放外部，因为这样对方可能没有你的外部库，没法直接运行，所以把它直接放在src源文件里



